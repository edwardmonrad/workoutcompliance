<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TrackCheck â€” Running Compliance</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Barlow:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
<style>
  :root {
    --bg: #0e0f13;
    --surface: #16181f;
    --surface2: #1e2029;
    --border: #2a2d3a;
    --accent: #c8f55a;
    --accent2: #5af5c8;
    --warn: #f5c85a;
    --danger: #f55a5a;
    --text: #e8eaf0;
    --text-dim: #6b7080;
    --text-mid: #a0a8b8;
    --mono: 'Space Mono', monospace;
    --sans: 'Barlow', sans-serif;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--sans);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: 
      linear-gradient(rgba(200,245,90,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(200,245,90,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .app {
    position: relative;
    z-index: 1;
    max-width: 960px;
    margin: 0 auto;
    padding: 40px 24px 80px;
  }

  /* Header */
  header {
    display: flex;
    align-items: baseline;
    gap: 16px;
    margin-bottom: 48px;
  }

  .logo {
    font-family: var(--mono);
    font-size: 22px;
    font-weight: 700;
    color: var(--accent);
    letter-spacing: -1px;
  }

  .logo span {
    color: var(--text-dim);
    font-weight: 400;
  }

  .tagline {
    font-size: 12px;
    color: var(--text-dim);
    letter-spacing: 2px;
    text-transform: uppercase;
    font-weight: 500;
  }

  /* Cards */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 28px;
    margin-bottom: 20px;
  }

  .card-title {
    font-family: var(--mono);
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 20px;
  }

  /* Step indicators */
  .steps {
    display: flex;
    gap: 8px;
    margin-bottom: 32px;
  }

  .step {
    flex: 1;
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    transition: background 0.3s;
  }

  .step.active { background: var(--accent); }
  .step.done { background: var(--accent2); }

  /* Inputs */
  .field {
    margin-bottom: 16px;
  }

  label {
    display: block;
    font-size: 11px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 8px;
    font-weight: 600;
  }

  input[type="text"], input[type="password"] {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 12px 16px;
    color: var(--text);
    font-family: var(--mono);
    font-size: 13px;
    outline: none;
    transition: border-color 0.2s;
  }

  input[type="text"]:focus, input[type="password"]:focus {
    border-color: var(--accent);
  }

  .hint {
    font-size: 12px;
    color: var(--text-dim);
    margin-top: 6px;
    line-height: 1.5;
  }

  /* File upload */
  .upload-zone {
    border: 2px dashed var(--border);
    border-radius: 6px;
    padding: 32px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
  }

  .upload-zone:hover, .upload-zone.drag-over {
    border-color: var(--accent);
    background: rgba(200,245,90,0.04);
  }

  .upload-zone input {
    position: absolute;
    inset: 0;
    opacity: 0;
    cursor: pointer;
    width: 100%;
    height: 100%;
  }

  .upload-icon {
    font-size: 28px;
    margin-bottom: 12px;
  }

  .upload-text {
    font-size: 14px;
    color: var(--text-mid);
  }

  .upload-text strong {
    color: var(--accent);
  }

  .upload-success {
    color: var(--accent2);
    font-family: var(--mono);
    font-size: 13px;
    margin-top: 8px;
  }

  /* Buttons */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px 24px;
    border-radius: 4px;
    font-family: var(--mono);
    font-size: 13px;
    font-weight: 700;
    letter-spacing: 0.5px;
    cursor: pointer;
    border: none;
    transition: all 0.15s;
    text-transform: uppercase;
  }

  .btn-primary {
    background: var(--accent);
    color: #0e0f13;
  }

  .btn-primary:hover { background: #d4f76b; transform: translateY(-1px); }
  .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

  .btn-secondary {
    background: transparent;
    color: var(--text-mid);
    border: 1px solid var(--border);
  }

  .btn-secondary:hover { border-color: var(--text-mid); color: var(--text); }

  .btn-row {
    display: flex;
    gap: 12px;
    margin-top: 20px;
    align-items: center;
  }

  /* Status */
  .status-line {
    font-family: var(--mono);
    font-size: 12px;
    color: var(--text-dim);
    margin-top: 12px;
    min-height: 18px;
  }

  .status-line.ok { color: var(--accent2); }
  .status-line.err { color: var(--danger); }
  .status-line.warn { color: var(--warn); }

  /* Results */
  #results { display: none; }

  .results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
  }

  .results-title {
    font-family: var(--mono);
    font-size: 18px;
    color: var(--accent);
  }

  .results-meta {
    font-size: 12px;
    color: var(--text-dim);
    font-family: var(--mono);
  }

  /* Summary stats */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    margin-bottom: 24px;
  }

  .stat-box {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 16px;
    text-align: center;
  }

  .stat-value {
    font-family: var(--mono);
    font-size: 28px;
    font-weight: 700;
    line-height: 1;
    margin-bottom: 6px;
  }

  .stat-label {
    font-size: 10px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--text-dim);
  }

  .stat-value.green { color: var(--accent); }
  .stat-value.blue { color: var(--accent2); }
  .stat-value.yellow { color: var(--warn); }
  .stat-value.red { color: var(--danger); }

  /* Week sections */
  .week-block {
    margin-bottom: 24px;
  }

  .week-header {
    font-family: var(--mono);
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--text-dim);
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
    margin-bottom: 12px;
  }

  /* Day rows */
  .day-row {
    display: grid;
    grid-template-columns: 80px 1fr 1fr 120px;
    gap: 12px;
    align-items: start;
    padding: 14px 0;
    border-bottom: 1px solid rgba(42,45,58,0.5);
  }

  .day-row:last-child { border-bottom: none; }

  .day-label {
    font-family: var(--mono);
    font-size: 12px;
    color: var(--text-dim);
    font-weight: 700;
    padding-top: 2px;
  }

  .day-label .date {
    display: block;
    font-size: 10px;
    font-weight: 400;
    margin-top: 2px;
  }

  .prescribed-text {
    font-size: 13px;
    color: var(--text-mid);
    line-height: 1.5;
  }

  .prescribed-text .intensity {
    font-family: var(--mono);
    font-size: 11px;
    color: var(--accent);
    background: rgba(200,245,90,0.08);
    padding: 1px 5px;
    border-radius: 3px;
  }

  .actual-text {
    font-size: 13px;
    color: var(--text-mid);
    line-height: 1.5;
  }

  .actual-text .no-data {
    color: var(--text-dim);
    font-style: italic;
  }

  /* Compliance badge */
  .compliance-badge {
    display: inline-flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 4px;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    padding: 3px 10px;
    border-radius: 20px;
    font-family: var(--mono);
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }

  .badge.pass { background: rgba(90,245,200,0.12); color: var(--accent2); border: 1px solid rgba(90,245,200,0.25); }
  .badge.fail { background: rgba(245,90,90,0.12); color: var(--danger); border: 1px solid rgba(245,90,90,0.25); }
  .badge.warn { background: rgba(245,200,90,0.12); color: var(--warn); border: 1px solid rgba(245,200,90,0.25); }
  .badge.skip { background: rgba(107,112,128,0.12); color: var(--text-dim); border: 1px solid rgba(107,112,128,0.25); }
  .badge.rest { background: transparent; color: var(--text-dim); border: 1px solid var(--border); }

  /* Lap detail */
  .lap-detail {
    margin-top: 8px;
    padding: 10px 12px;
    background: var(--bg);
    border-radius: 4px;
    border-left: 2px solid var(--border);
  }

  .lap-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 3px 0;
    font-family: var(--mono);
    font-size: 11px;
  }

  .lap-row .lap-name { color: var(--text-dim); }
  .lap-row .lap-target { color: var(--text-mid); }
  .lap-row .lap-actual { color: var(--text); }
  .lap-row .lap-delta { font-weight: 700; }
  .lap-row .lap-delta.ok { color: var(--accent2); }
  .lap-row .lap-delta.close { color: var(--warn); }
  .lap-row .lap-delta.off { color: var(--danger); }

  /* Loading */
  .loading {
    display: none;
    text-align: center;
    padding: 40px;
  }

  .loading.active { display: block; }

  .spinner {
    width: 32px;
    height: 32px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin: 0 auto 16px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text {
    font-family: var(--mono);
    font-size: 12px;
    color: var(--text-dim);
    letter-spacing: 1px;
  }

  /* Pace chip */
  .pace-chip {
    font-family: var(--mono);
    font-size: 11px;
    color: var(--accent2);
    background: rgba(90,245,200,0.08);
    padding: 1px 6px;
    border-radius: 3px;
    white-space: nowrap;
  }

  /* Toggle */
  .expand-btn {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--text-dim);
    background: none;
    border: none;
    cursor: pointer;
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-top: 6px;
    padding: 0;
  }

  .expand-btn:hover { color: var(--accent); }

  /* Responsive */
  @media (max-width: 640px) {
    .day-row { grid-template-columns: 60px 1fr; }
    .actual-text, .compliance-badge { grid-column: 2; }
    .stats-grid { grid-template-columns: repeat(2, 1fr); }
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">Track<span>Check</span></div>
    <div class="tagline">Training Compliance Analyser</div>
  </header>

  <!-- Steps -->
  <div class="steps">
    <div class="step active" id="step1"></div>
    <div class="step" id="step2"></div>
    <div class="step" id="step3"></div>
  </div>

  <!-- Step 1: Connect Strava -->
  <div class="card" id="card-strava">
    <div class="card-title">01 â€” Connect Strava</div>
    <div class="field">
      <label>Client ID</label>
      <input type="text" id="client-id-input" placeholder="e.g. 200921">
      <div class="hint">Found at strava.com/settings/api</div>
    </div>
    <div class="field">
      <label>Client Secret</label>
      <input type="password" id="client-secret-input" placeholder="Your Strava app client secret">
      <div class="hint">Found at strava.com/settings/api â€” stays in your browser, never sent anywhere except Strava.</div>
    </div>
    <div class="btn-row">
      <button class="btn btn-primary" onclick="startOAuth()">Authorise with Strava â†’</button>
      <div class="status-line" id="strava-status"></div>
    </div>
  </div>

  <!-- Step 2: Upload Training Plan -->
  <div class="card" id="card-plan" style="opacity:0.4; pointer-events:none;">
    <div class="card-title">02 â€” Upload Training Plan</div>
    <div class="upload-zone" id="upload-zone">
      <input type="file" id="plan-file" accept=".docx" onchange="handleFile(this.files[0])">
      <div class="upload-icon">ðŸ“„</div>
      <div class="upload-text">Drop your <strong>.docx</strong> training plan here or click to browse</div>
      <div class="upload-success" id="upload-success" style="display:none;"></div>
    </div>
    <div class="hint" style="margin-top:12px;">Upload the 3-week plan from your coach. The app will parse workouts for each day.</div>
    <div id="debug-section" style="display:none; margin-top:16px;">
      <div class="card-title">Raw extracted text (for debugging)</div>
      <textarea id="debug-text" style="width:100%; height:200px; background:var(--bg); color:var(--text-dim); border:1px solid var(--border); border-radius:4px; padding:12px; font-family:var(--mono); font-size:11px;" readonly></textarea>
    </div>
    <div class="btn-row">
      <button class="btn btn-primary" id="analyse-btn" onclick="runAnalysis()" disabled>Analyse â†’</button>
      <div class="status-line" id="plan-status"></div>
    </div>
  </div>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">Fetching activities from Strava...</div>
  </div>

  <!-- Results -->
  <div id="results">
    <div class="results-header">
      <div class="results-title">Compliance Report</div>
      <div class="results-meta" id="results-meta"></div>
    </div>
    <div class="stats-grid" id="stats-grid"></div>
    <div id="results-body"></div>
  </div>

</div>

<script>
// â”€â”€â”€ Pace table for your row (33:00 10k) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PACE_TABLE = {
  // seconds per km
  'd1':   272,  // 4:32/km (75%)
  'd2':   240,  // 4:00/km (85%)
  'd3':   217,  // 3:37/km (92%)
  'vlot': 208,  // 3:28/km (HM pace = 98%)
  'viad': 208,  // 3:28/km (16k pace = same row)
  'snel': 198,  // 3:18/km (10k pace = 100%)
  // numbered paces (seconds per metre, converted to s/km)
  '1':    190,  // 5k pace  = 3:10/km
  '2':    184,  // 3k pace  = 3:04/km
  '3':    173,  // 1500m    = 2:53/km (4:18 / 1.5)
  '4':    160,  // 800m     = 2:40/km (2:07 / 0.8)
  '5':    135,  // 400m     = 2:15/km (54s / 0.4)
};

// Tolerance settings
const TRACK_TOLERANCE_SEC = 3;   // Â±3 sec/km for track effort laps
const EASY_DURATION_TOL   = 0.15; // Â±15% for non-track duration
const ZONE_TOLERANCE_SEC  = 30;  // one zone â‰ˆ 30 sec/km tolerance for easy runs

let stravaToken  = null;
let athleteData  = null;
let planData     = null;
let activities   = [];

// â”€â”€â”€ Strava OAuth â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startOAuth() {
  const clientId = document.getElementById('client-id-input').value.trim();
  const secret   = document.getElementById('client-secret-input').value.trim();
  if (!clientId || !secret) {
    setStatus('strava-status', 'Please enter your Client ID and Client Secret first', 'err');
    return;
  }
  // Store credentials temporarily for after the redirect
  sessionStorage.setItem('strava_client_id', clientId);
  sessionStorage.setItem('strava_client_secret', secret);
  const redirectUri = encodeURIComponent(window.location.href.split('?')[0]);
  const url = 'https://www.strava.com/oauth/authorize?client_id=' + clientId + '&redirect_uri=' + redirectUri + '&response_type=code&scope=activity:read_all';
  window.location.href = url;
}

// Check if returning from OAuth with a code â€” if so, exchange for token automatically
async function checkOAuthReturn() {
  const params = new URLSearchParams(window.location.search);
  const code   = params.get('code');
  if (!code) return;

  window.history.replaceState({}, '', window.location.pathname);

  const clientId = sessionStorage.getItem('strava_client_id');
  const secret   = sessionStorage.getItem('strava_client_secret');
  if (!clientId || !secret) {
    setStatus('strava-status', 'OAuth code received but credentials not found â€” please re-enter and try again', 'err');
    return;
  }

  setStatus('strava-status', 'Exchanging code for token...', '');
  try {
    const res = await fetch('https://www.strava.com/oauth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ client_id: clientId, client_secret: secret, code, grant_type: 'authorization_code' })
    });
    const data = await res.json();
    if (data.access_token) {
      stravaToken = data.access_token;
      athleteData = data.athlete;
      sessionStorage.removeItem('strava_client_secret');
      // Pre-fill the fields for display
      document.getElementById('client-id-input').value = clientId;
      setStatus('strava-status', 'âœ“ Connected as ' + athleteData.firstname + ' ' + athleteData.lastname, 'ok');
      enableStep2();
      setStepDone(1);
    } else {
      setStatus('strava-status', 'Token exchange failed: ' + (data.message || JSON.stringify(data)), 'err');
    }
  } catch(e) {
    setStatus('strava-status', 'Token exchange error: ' + e.message, 'err');
  }
}

// â”€â”€â”€ Strava connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function connectStrava() {
  const token = document.getElementById('token-input').value.trim();
  if (!token) return setStatus('strava-status', 'Please enter a token', 'err');

  setStatus('strava-status', 'Connecting...', '');
  try {
    const res = await fetch('https://www.strava.com/api/v3/athlete', {
      headers: { Authorization: `Bearer ${token}` }
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    athleteData = await res.json();
    stravaToken = token;
    setStatus('strava-status', `âœ“ Connected as ${athleteData.firstname} ${athleteData.lastname}`, 'ok');
    enableStep2();
    setStepDone(1);
  } catch (e) {
    setStatus('strava-status', `Connection failed: ${e.message}`, 'err');
  }
}

function enableStep2() {
  const card = document.getElementById('card-plan');
  card.style.opacity = '1';
  card.style.pointerEvents = 'auto';
  document.getElementById('step2').classList.add('active');
}

// â”€â”€â”€ File handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handleFile(file) {
  if (!file) return;
  setStatus('plan-status', 'Parsing plan...', '');
  try {
    const arrayBuffer = await file.arrayBuffer();
    const result = await mammoth.extractRawText({ arrayBuffer });
    const text = result.value;
    // Show debug output
    document.getElementById('debug-text').value = text.slice(0, 3000);
    document.getElementById('debug-section').style.display = 'block';
    planData = parseTrainingPlan(text);
    const dayCount = Object.values(planData.weeks).flat().length;
    document.getElementById('upload-success').textContent = `âœ“ ${file.name} â€” ${Object.keys(planData.weeks).length} weeks, ${dayCount} sessions parsed`;
    document.getElementById('upload-success').style.display = 'block';
    document.getElementById('analyse-btn').disabled = false;
    setStatus('plan-status', '', '');
    setStepDone(2);
    document.getElementById('step3').classList.add('active');
  } catch (e) {
    setStatus('plan-status', `Parse error: ${e.message}`, 'err');
    console.error(e);
  }
}

// â”€â”€â”€ Training plan parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Mammoth extractRawText gives clean plain text. Structure:
//   "9 februari - 15 februari"  <- date range
//   "7"                          <- week number (small int)
//   "ma"                         <- day abbreviation
//   workout lines...
//   "di"                         <- next day
// Noise: loopscholing, atletische, bedoeling, uitvoering, km totals

function parseTrainingPlan(text) {
  const monthMap = { januari:0, februari:1, maart:2, april:3, mei:4, juni:5, juli:6, augustus:7, september:8, oktober:9, november:10, december:11 };
  const dayMap   = { ma:'monday', di:'tuesday', wo:'wednesday', do:'thursday', vr:'friday', za:'saturday', zo:'sunday' };
  const trackDays = new Set(['monday','wednesday']);
  const now = new Date();
  const year = now.getFullYear();

  // Stop at wedstrijdkalender or pace table
  let lines = text.split('\n');
  const stopIdx = lines.findIndex(l => ['wedstrijdkalender','WR-man','WR-vrouw'].some(m => l.includes(m)));
  if (stopIdx > 0) lines = lines.slice(0, stopIdx);

  // Lines to skip
  const isNoise = l => {
    const t = l.trim();
    if (!t || t === '\u00a0') return true;
    if (/^loopscholing/i.test(t)) return true;
    if (/^atletische/i.test(t)) return true;
    if (/^bedoel/i.test(t)) return true;
    if (/^uitvoering/i.test(t)) return true;
    if (/^doel:/i.test(t)) return true;
    if (/^km['\s]/i.test(t) || t.toLowerCase() === "km's") return true;
    if (/^(hoog|midden|laag)$/i.test(t)) return true;
    if (/^\d+$/.test(t) && parseInt(t) > 20) return true; // km totals
    return false;
  };

  const weeks = {};
  let currentWeekKey = null;
  let currentStartDate = null;
  let currentDay = null;
  let weekNum = null;

  for (const raw of lines) {
    const t = raw.trim();

    if (!t || t === '\u00a0') { continue; }
    if (isNoise(t)) continue;

    // Date range: "9 februari - 15 februari"
    const dateMatch = t.match(/^(\d+)\s+(\w+)\s*[-\u2013]\s*(\d+)\s+(\w+)$/i);
    if (dateMatch) {
      const d1 = parseInt(dateMatch[1]);
      const m1 = monthMap[dateMatch[2].toLowerCase()];
      if (m1 !== undefined) {
        currentStartDate = new Date(year, m1, d1);
        currentWeekKey = t;
        weeks[currentWeekKey] = [];
        currentDay = null;
      }
      continue;
    }

    // Week number (standalone small integer <= 20)
    if (/^\d+$/.test(t) && parseInt(t) <= 20) {
      weekNum = parseInt(t);
      continue;
    }

    // Day abbreviation on its own line
    if (dayMap[t.toLowerCase()] && currentWeekKey) {
      const dayName = dayMap[t.toLowerCase()];
      let date = null;
      if (currentStartDate) {
        const dow = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'].indexOf(dayName);
        const startDow = (currentStartDate.getDay() + 6) % 7; // Mon=0
        const diff = (dow - startDow + 7) % 7;
        date = new Date(currentStartDate);
        date.setDate(date.getDate() + diff);
      }
      currentDay = {
        dayName, date,
        dateStr: date ? formatDate(date) : null,
        isTrackDay: trackDays.has(dayName),
        rawLines: [],
        workout: null,
        weekLabel: currentWeekKey,
        weekNum
      };
      weeks[currentWeekKey].push(currentDay);
      continue;
    }

    // Workout content â€” append to current day
    if (currentDay) {
      currentDay.rawLines.push(t);
    }
  }

  // Join raw lines and parse each day's workout
  for (const days of Object.values(weeks)) {
    for (const day of days) {
      day.raw = day.rawLines.join(' ').trim();
      day.workout = parseWorkout(day.raw, day.dayName);
      delete day.rawLines;
    }
  }

  return { weeks, rawText: text };
}
function parseWorkout(text, dayName) {
  if (!text) return { type: 'unknown', raw: text };
  const t = text.toLowerCase().trim();

  // Rest day
  if (t === 'rust' || t.startsWith('rust')) return { type: 'rest', raw: text };

  // Track workouts â€” look for interval patterns
  const isTrack = ['ma', 'monday', 'wo', 'wednesday'].includes(dayName) ||
    /\d+\s*x\s*[\d(]/i.test(t) ||
    /\d+\s*Ã¡\s*\d+\s*x/i.test(t) ||
    /\d+\s*a\s*\d+\s*x/i.test(t);

  if (isTrack && /\d+/.test(t)) {
    return parseTrackWorkout(text);
  }

  // Easy/moderate runs
  return parseEasyWorkout(text);
}

function parseEasyWorkout(text) {
  const t = text.toLowerCase();
  const workout = { type: 'easy', raw: text, prescription: {} };

  // Duration: "40' - 60'" or "120' - 140'" or "90'"
  const durMatch = t.match(/(\d+)'\s*[-â€“]\s*(\d+)'|(\d+)'/);
  if (durMatch) {
    workout.prescription.durationMin = parseInt(durMatch[1] || durMatch[3]);
    workout.prescription.durationMax = parseInt(durMatch[2] || durMatch[3]);
  }

  workout.prescription.zone = extractMainZone(t);
  return workout;
}

function extractMainZone(text) {
  const t = text.toLowerCase();
  if (t.includes('d1') || t.includes('loslopen') || t.includes('herstel')) return 'd1';
  if (t.includes('d2')) return 'd2';
  if (t.includes('d3')) return 'd3';
  if (t.includes('vlot')) return 'vlot';
  if (t.includes('viad')) return 'viad';
  if (t.includes('snel')) return 'snel';
  if (t.includes('fartlek')) return 'd2';
  return null;
}

function parseTrackWorkout(text) {
  const t = text.toLowerCase();
  const workout = { type: 'track', raw: text, prescription: {} };

  // Overall set count: "3 x", "6 Ã¡ 7 x", "3 a 4 x"
  const setMatch = t.match(/(\d+)\s*[Ã¡Ã a]\s*(\d+)\s*x|(\d+)\s*x/i);
  if (setMatch) {
    workout.prescription.setsMin = parseInt(setMatch[1] || setMatch[3]);
    workout.prescription.setsMax = parseInt(setMatch[2] || setMatch[3]);
  }

  // Rest info
  const pMatch  = t.match(/\bp[/=]([^,\s]+)/i);
  const spMatch = t.match(/\bsp[/=]([^,\s]+)/i);
  if (pMatch)  workout.prescription.pause = pMatch[1];
  if (spMatch) workout.prescription.seriesPause = spMatch[1];

  // Build the ordered effort sequence (one entry per effort lap per set)
  workout.prescription.effortSequence = buildEffortSequence(text, workout.prescription);
  workout.prescription.paces = [...new Set(workout.prescription.effortSequence.map(e => e.pace))];

  return workout;
}

// Build the ordered sequence of effort laps for one set, then expand by set count.
// Returns array of { dist, pace } in order, repeated setsMax times.
function buildEffortSequence(text, prescription) {
  const perSet = parseSetStructure(text);
  if (!perSet.length) return [];

  const setsMax = prescription.setsMax || prescription.setsMin || 1;
  const result = [];
  for (let s = 0; s < setsMax; s++) {
    for (const effort of perSet) result.push({ ...effort });
  }
  return result;
}

// Parse the effort laps within one set from the workout text.
// Returns ordered array of { dist, pace }.
function parseSetStructure(text) {
  const t = text.toLowerCase();
  const efforts = [];

  // Strategy: find all "Nm pace" or "NxYm pace" patterns in order.
  // We walk the string and collect them.

  // First, strip the outer set multiplier ("3 x (...)") to get inner content
  // Try to extract the parenthesised set body
  const setBodyMatch = text.match(/\d+\s*[xXÃ—]\s*\(([^)]+(?:\([^)]*\)[^)]*)*)\)/);
  const body = setBodyMatch ? setBodyMatch[1] : text;

  // Also handle "Nm: Xm pace + Ym pace" format (week 9 wed style)
  // and inline list format (week 7 mon style)

  // Pattern: optional "Nx" multiplier, then distance, then pace
  // e.g. "800m vlot", "3x300m snel", "200m (2)", "1000m WT (200m (1)/vlot)"
  const re = /(\d+)\s*[xXÃ—]\s*(\d+)m\s+([^,+()\n]+)|(\d+)m\s+([^,+()\n]+)/gi;
  let m;
  const src = body || text;
  while ((m = re.exec(src)) !== null) {
    if (m[1] && m[2] && m[3]) {
      // "3x300m snel" style
      const count = parseInt(m[1]);
      const dist  = parseInt(m[2]);
      const pace  = pickPace(m[3]);
      if (pace) for (let i = 0; i < count; i++) efforts.push({ dist, pace });
    } else if (m[4] && m[5]) {
      // "800m vlot" style
      const dist = parseInt(m[4]);
      const pace = pickPace(m[5]);
      if (pace) efforts.push({ dist, pace });
    }
  }

  // Special: "1x 1000m vlot" prefix before the main sets (week 7 wed)
  // Already captured above since we scan full text

  return efforts;
}

// Given a pace description string, return the best single pace key.
// For ambiguous cases like "(4) a (5)" take the slower one (higher sec/km).
// For "WT (200m (1)/vlot)" treat as vlot (the easier of the two = slower).
// For "climaxloop (1) -> (2)" treat as midpoint.
function pickPace(str) {
  const s = str.toLowerCase().trim();
  const keys = [];

  // Named zones
  for (const key of ['snel','viad','vlot','d3','d2','d1']) {
    if (s.includes(key)) keys.push(key);
  }
  // Numbered (1)-(5)
  const nums = [...s.matchAll(/\((\d)\)/g)];
  for (const n of nums) {
    if (PACE_TABLE[n[1]]) keys.push(n[1]);
  }

  if (!keys.length) return null;
  if (keys.length === 1) return keys[0];

  // Multiple: for "a (5)" range take slower (higher sec/km = lower speed)
  // For WT workouts take the slower
  // For climaxloop take the midpoint â€” approximate with slower
  return keys.reduce((a, b) => PACE_TABLE[a] > PACE_TABLE[b] ? a : b);
}

function extractPaces(text) {
  const paces = [];
  const patterns = [
    { re: /\bsnel\b/gi,   key: 'snel' },
    { re: /\bviad\b/gi,   key: 'viad' },
    { re: /\bvlot\b/gi,   key: 'vlot' },
    { re: /\bd3\b/gi,     key: 'd3'   },
    { re: /\bd2\b/gi,     key: 'd2'   },
    { re: /\bd1\b/gi,     key: 'd1'   },
    { re: /\(([1-5])\)/g, key: null   },
  ];
  for (const p of patterns) {
    const matches = [...text.matchAll(p.re)];
    for (const m of matches) {
      const key = p.key || m[1];
      if (PACE_TABLE[key] && !paces.includes(key)) paces.push(key);
    }
  }
  return paces;
}

// â”€â”€â”€ Strava activity fetching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchActivities(afterEpoch, beforeEpoch) {
  const all = [];
  let page = 1;
  while (true) {
    const url = `https://www.strava.com/api/v3/athlete/activities?after=${afterEpoch}&before=${beforeEpoch}&per_page=50&page=${page}`;
    const res = await fetch(url, { headers: { Authorization: `Bearer ${stravaToken}` } });
    if (!res.ok) throw new Error(`Strava API error ${res.status}`);
    const batch = await res.json();
    if (!batch.length) break;
    all.push(...batch);
    page++;
  }
  return all;
}

async function fetchActivityLaps(activityId) {
  const res = await fetch(`https://www.strava.com/api/v3/activities/${activityId}/laps`, {
    headers: { Authorization: `Bearer ${stravaToken}` }
  });
  if (!res.ok) return [];
  return await res.json();
}

// â”€â”€â”€ Main analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function runAnalysis() {
  if (!planData || !stravaToken) return;

  document.getElementById('loading').classList.add('active');
  document.getElementById('results').style.display = 'none';

  try {
    // Determine date range from plan
    const allDays = Object.values(planData.weeks).flat().filter(d => d.date);
    if (!allDays.length) {
      setStatus('plan-status', 'Could not extract dates from plan', 'err');
      document.getElementById('loading').classList.remove('active');
      return;
    }

    const dates = allDays.map(d => d.date.getTime()).filter(Boolean);
    const minDate = new Date(Math.min(...dates));
    const maxDate = new Date(Math.max(...dates));

    // Fetch activities
    setLoading('Fetching activities from Strava...');
    const afterEpoch  = Math.floor(minDate.getTime() / 1000) - 86400;
    const beforeEpoch = Math.floor(maxDate.getTime() / 1000) + 86400;
    activities = await fetchActivities(afterEpoch, beforeEpoch);

    // For track days, fetch laps
    const trackDays = allDays.filter(d => d.isTrackDay && d.workout.type === 'track');
    setLoading(`Fetching lap data for ${trackDays.length} track sessions...`);

    for (const day of trackDays) {
      const activity = findActivity(activities, day.date);
      if (activity && !activity._laps) {
        activity._laps = await fetchActivityLaps(activity.id);
      }
    }

    // Run compliance checks
    setLoading('Calculating compliance...');
    const report = buildReport(planData, activities);

    // Render
    renderReport(report);
    document.getElementById('loading').classList.remove('active');
    document.getElementById('results').style.display = 'block';

  } catch (e) {
    document.getElementById('loading').classList.remove('active');
    setStatus('plan-status', `Analysis error: ${e.message}`, 'err');
    console.error(e);
  }
}

function findActivity(activities, date) {
  if (!date) return null;
  const d = new Date(date);
  return activities.find(a => {
    const ad = new Date(a.start_date_local);
    return ad.getFullYear() === d.getFullYear() &&
           ad.getMonth()    === d.getMonth()    &&
           ad.getDate()     === d.getDate()      &&
           a.type === 'Run';
  }) || null;
}

// â”€â”€â”€ Compliance engine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildReport(planData, activities) {
  const weeks = [];
  let totalDays = 0, completed = 0, compliant = 0, skipped = 0;

  for (const [weekLabel, days] of Object.entries(planData.weeks)) {
    const weekResult = { label: weekLabel, days: [] };

    for (const day of days) {
      totalDays++;
      const activity = day.date ? findActivity(activities, day.date) : null;
      const result = checkCompliance(day, activity);
      weekResult.days.push({ day, activity, result });

      if (day.workout.type === 'rest') { totalDays--; continue; }
      if (!activity) { skipped++; continue; }
      completed++;
      if (result.overallPass) compliant++;
    }

    weeks.push(weekResult);
  }

  return { weeks, summary: { totalDays, completed, compliant, skipped } };
}

function checkCompliance(day, activity) {
  const result = { completed: !!activity, completionPass: false, precisionPass: null, overallPass: false, details: [] };

  if (day.workout.type === 'rest') {
    result.overallPass = true;
    result.type = 'rest';
    return result;
  }

  if (!activity) {
    result.type = 'missed';
    return result;
  }

  result.completionPass = true;

  if (day.workout.type === 'easy') {
    // Duration check
    const durationMins = activity.elapsed_time / 60;
    const wp = day.workout.prescription;
    let durationOk = true;

    if (wp.durationMin) {
      const target = wp.durationMax ? (wp.durationMin + wp.durationMax) / 2 : wp.durationMin;
      const tol = target * EASY_DURATION_TOL;
      durationOk = Math.abs(durationMins - target) <= tol + 5;
      result.details.push({
        label: 'Duration',
        target: wp.durationMax ? `${wp.durationMin}â€“${wp.durationMax} min` : `${wp.durationMin} min`,
        actual: `${Math.round(durationMins)} min`,
        ok: durationOk
      });
    }

    // Pace check
    const avgPaceSecPerKm = 1000 / (activity.average_speed);
    let paceOk = true;
    if (wp.zone && PACE_TABLE[wp.zone]) {
      const target = PACE_TABLE[wp.zone];
      const diff = avgPaceSecPerKm - target;
      paceOk = Math.abs(diff) <= ZONE_TOLERANCE_SEC;
      result.details.push({
        label: 'Avg pace',
        target: formatPace(target),
        actual: formatPace(avgPaceSecPerKm),
        delta: diff,
        ok: paceOk
      });
    }

    result.precisionPass = durationOk && paceOk;
    result.overallPass   = result.precisionPass;
    result.type = 'easy';

  } else if (day.workout.type === 'track') {
    // Completion: check roughly right number of reps
    result.type = 'track';
    const laps = activity._laps || [];

    // Strip warm-up (first lap) and cool-down (last lap)
    const mainLaps = laps.length > 2 ? laps.slice(1, -1) : laps;

    // Separate effort laps (faster than D2) from recovery laps
    const d2Pace = PACE_TABLE['d2'];
    const effortLaps  = mainLaps.filter(l => (1000 / l.average_speed) < d2Pace - 10);
    const recoveryLaps = mainLaps.filter(l => (1000 / l.average_speed) >= d2Pace - 10);

    const wp = day.workout.prescription;
    const expectedSets = wp.setsMax || wp.setsMin;

    // Completion check: did they do roughly the right reps?
    const repRatio = expectedSets ? effortLaps.length / expectedSets : 1;
    result.completionPass = !expectedSets || (repRatio >= 0.7);

    result.details.push({
      label: 'Effort laps',
      target: expectedSets ? `${wp.setsMin}${wp.setsMax !== wp.setsMin ? 'â€“' + wp.setsMax : ''} reps` : '?',
      actual: `${effortLaps.length} reps`,
      ok: result.completionPass
    });

    // Precision: match effort laps in order against the prescribed sequence
    const seq = wp.effortSequence || [];
    if (effortLaps.length > 0 && seq.length > 0) {
      let allOk = true;
      let anyChecked = false;
      const lapChecks = [];

      // Match laps to sequence positions in order
      // Use the shorter of the two lists â€” extra laps or missing laps are flagged
      const maxLaps = Math.max(effortLaps.length, seq.length);

      for (let i = 0; i < maxLaps; i++) {
        const lap = effortLaps[i];
        const prescribed = seq[i];

        if (!lap) {
          // Missing lap
          lapChecks.push({
            label: `Rep ${i+1} (${prescribed.dist}m expected)`,
            target: formatPace(PACE_TABLE[prescribed.pace]) + '/km (' + prescribed.pace + ')',
            actual: 'â€”',
            delta: null,
            ok: false
          });
          allOk = false;
          continue;
        }

        if (!prescribed) {
          // Extra lap beyond prescription â€” show but don't penalise
          const lapPace = 1000 / lap.average_speed;
          lapChecks.push({
            label: `Rep ${i+1} (${Math.round(lap.distance)}m â€” extra)`,
            target: 'â€”',
            actual: formatPace(lapPace),
            delta: null,
            ok: null
          });
          continue;
        }

        anyChecked = true;
        const lapPace = 1000 / lap.average_speed;
        const targetPaceVal = PACE_TABLE[prescribed.pace];
        const delta = lapPace - targetPaceVal;
        const ok = Math.abs(delta) <= TRACK_TOLERANCE_SEC;
        if (!ok) allOk = false;

        lapChecks.push({
          label: `Rep ${i+1} (${Math.round(lap.distance)}m / ${prescribed.dist}m)`,
          target: formatPace(targetPaceVal) + '/km (' + prescribed.pace + ')',
          actual: formatPace(lapPace),
          delta: delta,
          ok: ok
        });
      }

      result.lapChecks = lapChecks;
      result.precisionPass = anyChecked ? allOk : null;
    } else if (effortLaps.length > 0) {
      // No sequence parsed â€” show laps without targets
      result.lapChecks = effortLaps.map((lap, i) => ({
        label: `Rep ${i+1} (${Math.round(lap.distance)}m)`,
        target: 'â€”',
        actual: formatPace(1000 / lap.average_speed),
        delta: null,
        ok: null
      }));
      result.precisionPass = null;
    } else {
      result.precisionPass = null;
    }

    result.overallPass = result.completionPass && (result.precisionPass !== false);
  }

  return result;
}

// â”€â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderReport(report) {
  const { weeks, summary } = report;

  // Stats
  const complRate = summary.completed ? Math.round((summary.compliant / summary.completed) * 100) : 0;
  const compRate2 = summary.totalDays ? Math.round((summary.completed / summary.totalDays) * 100) : 0;
  document.getElementById('stats-grid').innerHTML = `
    <div class="stat-box">
      <div class="stat-value green">${compRate2}%</div>
      <div class="stat-label">Sessions Done</div>
    </div>
    <div class="stat-box">
      <div class="stat-value blue">${complRate}%</div>
      <div class="stat-label">Pace Compliant</div>
    </div>
    <div class="stat-box">
      <div class="stat-value yellow">${summary.completed}</div>
      <div class="stat-label">Completed</div>
    </div>
    <div class="stat-box">
      <div class="stat-value red">${summary.skipped}</div>
      <div class="stat-label">Missed</div>
    </div>
  `;

  document.getElementById('results-meta').textContent = `${athleteData.firstname} ${athleteData.lastname} Â· ${Object.keys(planData.weeks).length} weeks`;

  // Week blocks
  let html = '';
  for (const week of weeks) {
    html += `<div class="week-block">
      <div class="week-header">Week â€” ${week.label}</div>`;

    for (const { day, activity, result } of week.days) {
      if (day.workout.type === 'rest') {
        html += `<div class="day-row">
          <div class="day-label">${capDay(day.dayName)}<span class="date">${day.dateStr || ''}</span></div>
          <div class="prescribed-text">Rest</div>
          <div class="actual-text"></div>
          <div class="compliance-badge"><span class="badge rest">Rest</span></div>
        </div>`;
        continue;
      }

      const badge = getBadge(result);
      const prescribedHtml = formatPrescribed(day);
      const actualHtml = activity ? formatActual(activity, result) : `<span class="no-data">No activity recorded</span>`;

      html += `<div class="day-row">
        <div class="day-label">${capDay(day.dayName)}<span class="date">${day.dateStr || ''}</span></div>
        <div class="prescribed-text">${prescribedHtml}</div>
        <div class="actual-text">${actualHtml}</div>
        <div class="compliance-badge">${badge}</div>
      </div>`;

      // Lap details for track days
      if (result.lapChecks && result.lapChecks.length > 0) {
        const lapId = `laps-${day.dateStr}-${day.dayName}`;
        html += `<div style="padding: 0 0 12px 80px;">
          <button class="expand-btn" onclick="toggleLaps('${lapId}')">â–¶ Lap details</button>
          <div id="${lapId}" class="lap-detail" style="display:none;">
            <div class="lap-row" style="border-bottom:1px solid var(--border); margin-bottom:4px; padding-bottom:4px;">
              <span class="lap-name" style="width:140px">Rep</span>
              <span class="lap-target">Target</span>
              <span class="lap-actual">Actual</span>
              <span class="lap-delta">Î”</span>
            </div>`;
        for (const lc of result.lapChecks) {
          const cls = Math.abs(lc.delta) <= TRACK_TOLERANCE_SEC ? 'ok' : Math.abs(lc.delta) <= 8 ? 'close' : 'off';
          const sign = lc.delta > 0 ? '+' : '';
          html += `<div class="lap-row">
            <span class="lap-name" style="width:140px">${lc.label}</span>
            <span class="lap-target">${lc.target}/km</span>
            <span class="lap-actual">${lc.actual}/km</span>
            <span class="lap-delta ${cls}">${sign}${Math.round(lc.delta)}s</span>
          </div>`;
        }
        html += `</div></div>`;
      }
    }

    html += '</div>';
  }

  document.getElementById('results-body').innerHTML = html;
}

function getBadge(result) {
  if (result.type === 'rest') return `<span class="badge rest">Rest</span>`;
  if (result.type === 'missed') return `<span class="badge fail">âœ— Missed</span>`;

  const badges = [];
  if (result.completionPass) {
    badges.push(`<span class="badge pass">âœ“ Done</span>`);
  } else {
    badges.push(`<span class="badge fail">âœ— Incomplete</span>`);
  }

  if (result.precisionPass === true) {
    badges.push(`<span class="badge pass">âœ“ On pace</span>`);
  } else if (result.precisionPass === false) {
    badges.push(`<span class="badge warn">âš  Off pace</span>`);
  }

  return badges.join('');
}

function formatPrescribed(day) {
  if (!day.workout || day.workout.type === 'rest') return 'Rest';
  if (day.workout.type === 'easy') {
    const wp = day.workout.prescription;
    const dur = wp.durationMax ? `${wp.durationMin}â€“${wp.durationMax}â€²` : wp.durationMin ? `${wp.durationMin}â€²` : '';
    const zone = wp.zone ? `<span class="intensity">${wp.zone.toUpperCase()}</span>` : '';
    return `${dur} ${zone}`.trim() || day.workout.raw;
  }
  // Track: show cleaned description
  return day.workout.prescription.description || day.workout.raw;
}

function formatActual(activity, result) {
  const pace = formatPace(1000 / activity.average_speed);
  const dist = (activity.distance / 1000).toFixed(1);
  const dur  = formatDuration(activity.elapsed_time);
  return `${dist} km Â· ${dur} Â· <span class="pace-chip">${pace}/km avg</span>`;
}

// â”€â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function formatPace(secPerKm) {
  const s = Math.round(secPerKm);
  const m = Math.floor(s / 60);
  const rem = s % 60;
  return `${m}:${rem.toString().padStart(2,'0')}`;
}

function formatDuration(secs) {
  const h = Math.floor(secs / 3600);
  const m = Math.floor((secs % 3600) / 60);
  if (h > 0) return `${h}h${m.toString().padStart(2,'0')}â€²`;
  return `${m}â€²`;
}

function formatDate(date) {
  return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
}

function capDay(day) {
  return day.charAt(0).toUpperCase() + day.slice(1, 3);
}

function setStatus(id, msg, cls) {
  const el = document.getElementById(id);
  el.textContent = msg;
  el.className = 'status-line' + (cls ? ' ' + cls : '');
}

function setLoading(msg) {
  document.getElementById('loading-text').textContent = msg;
}

function setStepDone(n) {
  document.getElementById(`step${n}`).classList.add('done');
}

function toggleLaps(id) {
  const el = document.getElementById(id);
  const btn = el.previousElementSibling;
  if (el.style.display === 'none') {
    el.style.display = 'block';
    btn.textContent = 'â–¼ Lap details';
  } else {
    el.style.display = 'none';
    btn.textContent = 'â–¶ Lap details';
  }
}

checkOAuthReturn();

// Drag and drop
const zone = document.getElementById('upload-zone');
zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag-over'); });
zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
zone.addEventListener('drop', e => {
  e.preventDefault();
  zone.classList.remove('drag-over');
  const file = e.dataTransfer.files[0];
  if (file) handleFile(file);
});
</script>
</body>
</html>
